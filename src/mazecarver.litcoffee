This is not a very flexible command line program, mostly just here to
edit the code and up-arrow to generate.

    doc = """
    Usage:
      mazecarver <width-mm> <height-mm> <depth-mm> <width-cells> <height-cells> [<mask>...]

    Options:
      -h --help                show this help message and exit
      --version                show version and exit

    Generates the gcode to carve a random maze panel, you should consider
    610 1220 to do a normal 2x4 quarter sheet of ply.

    The width and height also needs cells which you can vary to taste. With a
    6.35mm cutter on a 1/2" quarter sheet, start with:
    610 1220 12.7 30 60

    Masking is specified in width/height coordinates from the lower-left
    to the upper right comma separated coordinates like so:
    10,10,100,100
    This will treat any cells that intersect with these coordinates as unreachable
    and will be held out of the maze generation. These are in cell coordinates,
    not in mm.

    Material top is Z0.


    """

    {docopt} = require 'docopt'
    require 'colors'
    _ = require 'lodash'
    options = docopt doc
    {suffix, prefix, SAFE_TRAVEL, RPM, FEEDRATE, PLUNGERATE} = require './lines.litcoffee'
    rectangle = require './rectangle.litcoffee'


This actually feels like an OO problem to me. So -- classes! With attributes
even...

    Function::property = (prop, desc) ->
      Object.defineProperty @prototype, prop, desc


This is the most basic cell, square maze grid.

    class SquareCell
      constructor: (@row, @column) ->
        @links = {}

      toString: ->
        "#{@row}, #{@column}"


Link makes a path between two cells.

      link: (cell, bidirectional=true) ->
        @links[cell] = true
        if bidirectional
          cell.link this, false


Unlink removes a path between two cells.

      unlink: (cell, bidirectional=true) ->
        delete @links[cell]
        if bidirectional
          cell.unlink this, false


All immediate neighbors.

      @property 'neighbors',
        get: -> _.select [@north, @east, @south, @west], (n) -> n


Any old neighbor.

      randomNeighbor: ->
        _.sample _.select @neighbors, (n) -> not n.visited


Set up the cells into a mesh, this is specific to the kind of cell, here
a square sets up 4 neighbors.

      meshNeighbors: (grid) ->
        if grid.mask.blocks @
          return
        north = grid.cellAt @row, @column + 1
        @north = north unless grid.mask.blocks north
        south = grid.cellAt @row, @column - 1
        @south = south unless grid.mask.blocks south
        east = grid.cellAt @row + 1, @column
        @east = east unless grid.mask.blocks east
        west = grid.cellAt @row - 1, @column
        @west = west unless grid.mask.blocks west


Grid of cells, assuming starting at the lower left, moving to the
upper right. Pass in the cell type to make the members of the grid.

    class Maze


Build up a maze as an array of cells, stored run length encoded, contiguous
rows. Them actual maze is generated by random visitation until all cells
have been visited.

A 'path' is built up of linked cell pairs and reversals. This path is then
translated into cutting lines.

      constructor: (@width, @height, @mask, Cell=SquareCell) ->
        @cells = []
        @path = []
        _.range(@height).forEach (column) =>
          _.range(@width).forEach (row) =>
            @cells.push new Cell(row, column)
        @cells.forEach (cell) =>
          cell.meshNeighbors @
        stack = []
        at = @randomCell()
        stack.push at
        while stack.length
          at.visited = true
          if @mask.blocks at
            console.error "blocked by mask #{at}".red
          neighbor = at.randomNeighbor()
          if neighbor
            if @mask.blocks neighbor
              console.error "blocked by mask #{at}".red
            else
              at.link(neighbor)
              stack.push neighbor
              @path.push {from: at, to:neighbor}
              at = neighbor
          else
            reversal = stack.pop()
            @path.push {from: at, to:reversal, reversal: true}
            at = reversal


Offset of the run length encoding from above

      cellAt: (row, column) ->
        if _.inRange(row, @width) and _.inRange(column, @height)
          @cells[row+column*@width]
        else
          null


Randomly selected cell, this is used to generate the maze links between cells.

      randomCell: ->
        _.sample @cells


Generate gcode for the maze. Here are the rules:
- Drill mount holes at the perimiter
- Cut out walls, leave paths
- Do not cut the outsize walls, the sheet will fall apart!
- Do not cut walls if cells are linked, this is a path to follow

    class MultipassRender
      constructor: (@width, @height, @depth=12.7, @mountholeoffset=10.0) ->


Rendering sets up the gcode pre and post blocks to start the spindle and program
with a safe travel. This treats the machine tabletop as 0.

      render: (maze) ->
        cellWidth = @width / maze.width
        cellHeight = @height / maze.height
        ret = prefix('', RPM)

The cut action walks the path of the maze multiple times in order to generate
a smooth multipass cut removing layers of material on each pass.

There is a bit of path compression on the reversals, since the backtrack will
tend to chain. But, a trick, just pop up the Z, and let the cutter move to
the next real cut.

        steps = Math.ceil @depth / 3
        (-1 * i * ((@depth)/steps) for i in [1..steps]).forEach (z) ->
          maze.path.forEach (segment) =>
            if segment.reversal
              ret += "G0Z#{SAFE_TRAVEL}\n"
            else
              ret += "G1F#{FEEDRATE}X#{segment.from.row * cellWidth + .66 * cellWidth}Y#{segment.from.column * cellHeight + .5 * cellHeight}\n"
              ret += "G1F#{PLUNGERATE}Z#{z}\n"
              ret += "G1F#{FEEDRATE}X#{segment.to.row * cellWidth + .66 * cellWidth}Y#{segment.to.column * cellHeight + .5 * cellHeight}\n"

And now -- the end, outline in a rectangle>

        ret += suffix()


Ahh, the mask, this sets up coordinate regions and tells you if a cell
is excluded by touching the mask at all.

    class Mask
      constructor: (masks) ->
        @masks = _.map masks, (mask) ->
          [llr, llc, urr, urc] = _.map mask.split(','), Number
          bound =
            lowerLeft:
              row: llr
              column: llc
            upperRight:
              row: urr
              column: urc


Say true if a given cell is blocked by the mask.

      blocks: (cell) ->
        if not cell
          false
        else
          _.any @masks, (mask) ->
           cell.row >= mask.lowerLeft.row and
             cell.column >= mask.lowerLeft.column and
             cell.row <= mask.upperRight.row and
             cell.column <= mask.upperRight.column


And after all those classes are defined, running the actual program isn't
all that eventful.

    maze = new Maze Number(options['<width-cells>']), Number(options['<height-cells>']), new Mask(options['<mask>'])
    console.log new MultipassRender(Number(options['<width-mm>']), Number(options['<height-mm>']), Number(options['<depth-mm>'])).render(maze)
