This is not a very flexible command line program, mostly just here to
edit the code and up-arrow to generate.

    doc = """
    Usage:
      mazecarver <width-mm> <height-mm> <thickness-mm> <width-cells> <height-cells> [<mask>...]

    Options:
      -h --help                show this help message and exit
      --version                show version and exit

    Generates the gcode to carve a random maze panel, you should consider
    610 1220 to do a normal 2x4 quarter sheet of ply.

    The width and height also needs cells which you can vary to taste. With a
    6.35mm cutter on a 1/2" quarter sheet, start with:
    610 1220 12.7 30 60

    Masking is specified in width/height coordinates from the lower-left
    to the upper right comma separated coordinates like so:
    10,10,100,100
    This will treat any cells that intersect with these coordinates as unreachable
    and will be held out of the maze generation. These are in cell coordinates,
    not in mm.


    """

    {docopt} = require 'docopt'
    require 'colors'
    _ = require 'lodash'
    options = docopt doc
    {suffix, prefix} = require './lines.litcoffee'
    line = require './line.litcoffee'


This actually feels like an OO problem to me. So -- classes! With attributes
even...

    Function::property = (prop, desc) ->
      Object.defineProperty @prototype, prop, desc


This is the most basic cell, square maze grid.

    class SquareCell
      constructor: (@row, @column) ->
        @links = {}

      toString: ->
        "#{@row}, #{@column}"


Link makes a path between two cells.

      link: (cell, bidirectional=true) ->
        @links[cell] = true
        if bidirectional
          cell.link this, false


Unlink removes a path between two cells.

      unlink: (cell, bidirectional=true) ->
        delete @links[cell]
        if bidirectional
          cell.unlink this, false


All immediate neighbors.

      @property 'neighbors',
        get: -> _.select [@north, @east, @south, @west], (n) -> n


Is this cell linkable and yet unlinked?

      @property 'unlinked',
        get: -> _.isEmpty @links


Any old neighbor.

      randomNeighbor: ->
        _.sample @neighbors


Cut out your walls. Limit cutting to the north and east to avoid
double cutting. It's a trick.
Cuts take the form:
 - make sure the cutter is safe height
 - move to the target
 - make multiple passes
 - the trailing blank line separates the cut blocks in the generated file

      cut: (widthmm, heightmm, depthmm, dedupe, line) ->
        lx = @row * widthmm
        rx = (@row+1) * widthmm
        ly = @column * heightmm
        uy = (@column+1) * heightmm
        if @neighbors.length
          ret = ""
          if not @links[@north]
            next = line lx, uy, rx, uy, -depthmm, 0
            if not dedupe[next]
              ret += next
              dedupe[next] = next
          if not @links[@east]
            next = line rx, uy, rx, ly, -depthmm, 0
            if not dedupe[next]
              ret += next
              dedupe[next] = next
          if not @links[@south]
            next = line lx, ly, rx, ly, -depthmm, 0
            if not dedupe[next]
              ret += next
              dedupe[next] = next
          if not @links[@west]
            next = line lx, ly, lx, uy, -depthmm, 0
            if not dedupe[next]
              ret += next
              dedupe[next] = next
          ret
        else
          ""


Set up the cells into a mesh, this is specific to the kind of cell, here
a square sets up 4 neighbors.

      meshNeighbors: (grid) ->
        if grid.mask.blocks @
          return
        north = grid.cellAt @row, @column + 1
        @north = north unless grid.mask.blocks north
        south = grid.cellAt @row, @column - 1
        @south = south unless grid.mask.blocks south
        east = grid.cellAt @row + 1, @column
        @east = east unless grid.mask.blocks east
        west = grid.cellAt @row - 1, @column
        @west = west unless grid.mask.blocks west


Grid of cells, assuming starting at the lower left, moving to the
upper right. Pass in the cell type to make the members of the grid.

    class Maze


Build up a maze as an array of cells, stored run length encoded, contiguous
rows. Them actual maze is generated by random visitation until all cells
have been visited.

      constructor: (@width, @height, @mask, Cell=SquareCell) ->
        @cells = []
        _.range(@height).forEach (column) =>
          _.range(@width).forEach (row) =>
            @cells.push new Cell(row, column)
        @cells.forEach (cell) =>
          cell.meshNeighbors @
        stack = []
        visitable = (cell) ->
          _.select(at?.neighbors, (neighbor) -> neighbor.unlinked).length
        until visitable(at)
          at = @randomCell()
        stack.push at
        while stack.length
          if @mask.blocks at
            console.error "horror #{at}".red
          at = stack[stack.length-1]
          if visitable(at)
            neighbor = at.randomNeighbor()
            if @mask.blocks neighbor
              console.error "horror #{at}".red
            at.link(neighbor)
            stack.push neighbor
          else
            stack.pop()

Offset of the run length encoding from above

      cellAt: (row, column) ->
        if _.inRange(row, @width) and _.inRange(column, @height)
          @cells[row+column*@width]
        else
          null


Randomly selected cell, this is used to generate the maze links between cells.

      randomCell: ->
        _.sample @cells


Generate gcode for the maze. Here are the rules:
- Drill mount holes at the perimiter
- Cut out walls, leave paths
- Do not cut the outsize walls, the sheet will fall apart!
- Do not cut walls if cells are linked, this is a path to follow

    class MultipassRender
      constructor: (@width, @height, @thickness=12.7, @mountholeoffset=10.0) ->


Rendering sets up the gcode pre and post blocks to start the spindle and program
with a safe travel. This treats the machine tabletop as 0.

      render: (maze) ->
        ret = prefix(7, 18000)

Here is the actual action, cutting out walls, leaving the path. This is unrolling
the cells back and forth to speed up the cut by avoiding seeks.

        mazeCuttableWidth = @width
        mazeCuttableHeight = @height
        dedupe = {}
        chunked = _.chunk maze.cells, maze.width
        lineBuffer = ""
        chunked.forEach (chunk, index) =>
         if index % 2
           chunk.reverse()
         chunk.forEach (cell) =>
           lineBuffer += cell.cut mazeCuttableWidth / maze.width, mazeCuttableHeight / maze.height, @thickness, dedupe, line

        ret = ret + lineBuffer

And now -- the end.

        ret += suffix()


Ahh, the mask, this sets up coordinate regions and tells you if a cell
is excluded by touching the mask at all.

    class Mask
      constructor: (masks) ->
        @masks = _.map masks, (mask) ->
          [llr, llc, urr, urc] = _.map mask.split(','), Number
          bound =
            lowerLeft:
              row: llr
              column: llc
            upperRight:
              row: urr
              column: urc


Say true if a given cell is blocked by the mask.

      blocks: (cell) ->
        if not cell
          false
        else
          _.any @masks, (mask) ->
           cell.row >= mask.lowerLeft.row and
             cell.column >= mask.lowerLeft.column and
             cell.row <= mask.upperRight.row and
             cell.column <= mask.upperRight.column


And after all those classes are defined, running the actual program isn't
all that eventful.

    maze = new Maze Number(options['<width-cells>']), Number(options['<height-cells>']), new Mask(options['<mask>'])
    console.log new MultipassRender(Number(options['<width-mm>']), Number(options['<height-mm>']), Number(options['<thickness-mm>'])).render(maze)
